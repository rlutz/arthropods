#!/usr/bin/python
# arthropods - Generate footprints for arthropodic components
# Copyright (C) 2015 Roland Lutz
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

import getopt, sys

ZERO, MM, MIL = xrange(3)
class Nanometers:
    """Represents a length as an integer of nanometers and a preferred unit."""
    def __init__(self, v, unit):
        if not isinstance(v, int) or unit not in [ZERO, MM, MIL]:
            raise ValueError
        self.v = v
        self.unit = unit
    def __cmp__(self, other):
        if not isinstance(other, Nanometers):
            return NotImplemented
        return cmp(self.v, other.v)
    def __add__(self, other):
        if not isinstance(other, Nanometers):
            return NotImplemented
        return Nanometers(
            self.v + other.v,
            ZERO if self.unit == ZERO and other.unit == ZERO else
            MIL if self.unit != MM and other.unit != MM else MM)
    def __sub__(self, other):
        if not isinstance(other, Nanometers):
            return NotImplemented
        return Nanometers(
            self.v - other.v,
            ZERO if self.unit == ZERO and other.unit == ZERO else
            MIL if self.unit != MM and other.unit != MM else MM)
    def __mul__(self, other):
        return Nanometers(self.v * other, self.unit)
    def __div__(self, other):
        return Nanometers(self.v / other, self.unit)
    __rmul__ = __mul__
    __rdiv__ = __div__
    def __neg__(self):
        return Nanometers(-self.v, self.unit)

def mm(v): return Nanometers(int(v * 1000000), MM)
def mil(v): return Nanometers(int(v * 25400), MIL)
zero = Nanometers(0, ZERO)

line_thickness = mil(10.)

pin_thickness = mm(1.5)
pin_clearance = mm(1.4)
pin_mask = mm(1.7)
pin_drill = mm(1.)

pad_thickness = mm(1.492)
pad_clearance = mm(1.4)
pad_mask = mm(1.69)

pad_length = mil(50.)

# Formatting a number of nanometers to a string in mm or mil.

def pcb_format(length):
    if not isinstance(length, Nanometers):
        raise ValueError
    if length.v == 0:
        return '0.0000'
    if length.unit == MIL:
        return '%.2f%s' % (length.v / 25400., 'mil')
    else:
        return '%.4f%s' % (length.v / 1000000., 'mm')

def user_format(length):
    if not isinstance(length, Nanometers):
        raise ValueError
    if length.v == 0:
        return '0'
    if length.unit == MIL:
        length, unit = '%.6f' % (length.v / 25400.), 'mil'
    else:
        length, unit = '%.6f' % (length.v / 1000000.), 'mm'
    length = length.strip('0')
    if length == '.':
        length = '0'
    else:
        length = length.rstrip('.')
    return length + unit

# Output

def start(flags, desc, name, value, mark_x, mark_y,
          text_x, text_y, text_dir, text_scale, text_flags):
    if isinstance(flags, list):
        flags = ','.join(flags)
    elif flags is None:
        flags = ""
    if name is None:
        name = desc
    if value is None:
        value = desc
    if isinstance(text_flags, list):
        text_flags = ','.join(text_flags)
    elif text_flags is None:
        text_flags = ""
    print 'Element["%s" "%s" "%s" "%s" %s %s %s %s %s %s "%s"]' % (
        flags, desc, name, value,
        pcb_format(mark_x), pcb_format(mark_y),
        pcb_format(text_x), pcb_format(text_y),
        text_dir, text_scale, text_flags)
    print '('

def pin(x, y, thickness, clearance, mask, drill,
        name, number = None, flags = None):
    if number is None:
        number = name
    if isinstance(flags, list):
        flags = ','.join(flags)
    elif flags is None:
        flags = ""
    print "\tPin[%s %s %s %s %s %s \"%s\" \"%s\" \"%s\"]" % (
        pcb_format(x), pcb_format(y),
        pcb_format(thickness), pcb_format(clearance),
        pcb_format(mask), pcb_format(drill),
        name, number, flags)

def pad(x0, y0, x1, y1, thickness, clearance, mask,
        name, number = None, flags = None):
    if number is None:
        number = name
    if isinstance(flags, list):
        flags = ','.join(flags)
    elif flags is None:
        flags = ""
    print "\tPad[%s %s %s %s %s %s %s \"%s\" \"%s\" \"%s\"]" % (
        pcb_format(x0), pcb_format(y0), pcb_format(x1), pcb_format(y1),
        pcb_format(thickness), pcb_format(clearance), pcb_format(mask),
        name, number, flags)

def line(x0, y0, x1, y1):
    print "\tElementLine [%s %s %s %s %s]" % (
        pcb_format(x0), pcb_format(y0), pcb_format(x1), pcb_format(y1),
        pcb_format(line_thickness))

def arc(x, y, xradius, yradius, start_angle, delta_angle):
    print "\tElementArc [%s %s %s %s %d %d %s]" % (
        pcb_format(x), pcb_format(y), pcb_format(xradius), pcb_format(yradius),
        start_angle, delta_angle, pcb_format(line_thickness))

def end():
    print
    print "\t)"

# Parameter handling

STYLE_THICKENED, STYLE_DENT, STYLE_BOXED, STYLE_SOCKET, \
    STYLE_WSL_ARROW, STYLE_WSL_DENT, STYLE_PSL = xrange(7)
SHAPE_STRAIGHT, SHAPE_ZIGZAG, SHAPE_USHAPED, SHAPE_AB, SHAPE_BA = xrange(5)

def invalid_arguments(message):
    sys.stderr.write("%s: %s\n" % (sys.argv[0], message))
    sys.stderr.write("Try `%s --help' for more information.\n" % sys.argv[0])
    sys.exit(1)

def parse(length):
    """Parse a string in mm or mil to a number of nanometers."""
    unit = next(unit for unit in ['mm', 'mil', ''] if length.endswith(unit))
    if not isinstance(length, basestring) or not unit:
        invalid_arguments("`%s' is not a length in mm or mil" % length)
    if '.' in length:
        length = float(length[:-len(unit)])
    else:
        length = int(length[:-len(unit)])
    return { 'mm': mm, 'mil': mil }[unit](length)

def main():
    global pad_length
    global line_thickness, pin_thickness, pin_clearance, pin_mask, pin_drill, \
           pad_thickness, pad_clearance, pad_mask

    try:
        options, args = getopt.getopt(
            sys.argv[1:], 's:ZUABd:p:', [
                'style=',
                'straight', 'zigzag', 'u-shaped', 'ab', 'ba',
                'row-distance=', 'pad-length=',
                'line-thickness=',
                'pin-thickness=',
                'pin-clearance=',
                'pin-mask=',
                'pin-drill=',
                'pad-thickness=',
                'pad-clearance=',
                'pad-mask=',
                'help', 'version'
            ])
    except getopt.GetoptError as e:
        invalid_arguments(e.msg)

    style = STYLE_THICKENED
    shape = SHAPE_STRAIGHT
    row_distance = mil(100.)

    for option, value in options:
        if option in ['-s', '--style']:
            try:
                style = { 'thickened': STYLE_THICKENED,
                          'dent': STYLE_DENT,
                          'boxed': STYLE_BOXED,
                          'socket': STYLE_SOCKET,
                          'wsl-arrow': STYLE_WSL_ARROW,
                          'wsl-dent': STYLE_WSL_DENT,
                          'psl': STYLE_PSL
                }[value]
            except KeyError:
                invalid_arguments("`%s' is not a valid silk style" % value)
        elif option == '--straight':
            shape = SHAPE_STRAIGHT
        elif option in ['-Z', '--zigzag']:
            shape = SHAPE_ZIGZAG
        elif option in ['-U', '--u-shaped']:
            shape = SHAPE_USHAPED
        elif option in ['-A', '--ab']:
            shape = SHAPE_AB
        elif option in ['-B', '--ba']:
            shape = SHAPE_BA
        elif option in ['-d', '--row-distance']:
            row_distance = parse(value)
        elif option in ['-p', '--pad-length']:
            pad_length = parse(value)
        elif option == '--line-thickness':
            line_thickness = parse(value)
        elif option == '--pin-thickness':
            pin_thickness = parse(value)
        elif option == '--pin-clearance':
            pin_clearance = parse(value)
        elif option == '--pin-mask':
            pin_mask = parse(value)
        elif option == '--pin-drill':
            pin_drill = parse(value)
        elif option == '--pad-thickness':
            pad_thickness = parse(value)
        elif option == '--pad-clearance':
            pad_clearance = parse(value)
        elif option == '--pad-mask':
            pad_mask = parse(value)
        elif option == '--help':
            sys.stdout.write("""\
Usage: %s NAME PIN_COUNT
Generate footprints for arthropodic components

      -s, --style=thickened|dent|boxed|socket|wsl-arrow|wsl-dent|psl
                        use this style to indicate pin 1 on the silk layer

      --straight        one straight row of pins
      -Z, --zigzag      two rows of pins, numbered in zig-zag
      -U, --u-shaped    two rows of pins, numbered in an U shape
      -A, --ab          two rows of pins, numbered A1..An and B1..Bn
      -B, --ba          two rows of pins, numbered B1..Bn and A1..An

      -d, --row-distance=DISTANCE	[default: %s]
                        distance between the rows
      -p, --pad-length=LENGTH		[default: %s]
                        length of the solder pads

      --line-thickness=Xmm|Xmil	[default: %s]
      --pin-thickness=Xmm|Xmil	[default: %s]
      --pin-clearance=Xmm|Xmil	[default: %s]
      --pin-mask=Xmm|Xmil	[default: %s]
      --pin-drill=Xmm|Xmil	[default: %s]
      --pad-thickness=Xmm|Xmil	[default: %s]
      --pad-clearance=Xmm|Xmil	[default: %s]
      --pad-mask=Xmm|Xmil	[default: %s]

      --help            give this help
      --version         display version number
""" % (sys.argv[0],
       user_format(row_distance), user_format(pad_length),
       user_format(line_thickness),
       user_format(pin_thickness), user_format(pin_clearance),
         user_format(pin_mask), user_format(pin_drill),
       user_format(pad_thickness), user_format(pad_clearance),
         user_format(pad_mask)))
            sys.exit(0)
        elif option == '--version':
            sys.stdout.write("""\
Arthropods - footprint generator for arthropodic components
Copyright (C) 2015 Roland Lutz

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
""")
            sys.exit(0)
        else:
            raise AssertionError

    try:
        name, pin_count_str = args
    except ValueError:
        sys.stdout.write("Usage: %s NAME PIN_COUNT\n" % sys.argv[0])
        sys.stderr.write("Try `%s --help' for more information.\n"
                         % sys.argv[0])
        sys.exit(1)

    try:
        pin_count = int(pin_count_str)
    except ValueError:
        invalid_arguments("`%s' is not an integer" % pin_count_str)

    if shape != SHAPE_STRAIGHT and pin_count % 2 != 0:
        invalid_arguments("Pin count for zigzag/u-shaped/AB/BA must be even")

    if shape == SHAPE_STRAIGHT:
        rows = 1
        row_distance = zero
    else:
        rows = 2

    eff_pin_count = pin_count // rows

    # Calculate dimensions

    width = row_distance
    height = (eff_pin_count - 1) * mil(100.)

    if style in [STYLE_WSL_ARROW, STYLE_WSL_DENT]:
        x_offset = mil(125.)
        y_offset = mil(200.)
    else:
        x_offset = mil(50.)
        y_offset = mil(50.)

    x0 = -x_offset; x1 = width + x_offset
    y0 = -y_offset; y1 = height + y_offset

    if style == STYLE_DENT:
        text_x, text_y, text_dir, text_scale = \
          width / 2 + mil(30.), mil(25.), 3, 100
    elif style == STYLE_PSL:
        text_x, text_y, text_dir, text_scale = \
          mil(-68.11), mil(-506.69), 0, 100
    elif shape == SHAPE_STRAIGHT:
        text_x, text_y, text_dir, text_scale = \
          x1 + mil(70.), y0 + mil(5.), 3, 100
    else:
        text_x, text_y, text_dir, text_scale = \
          x0, y0 - mil(70.), 0, 100

    if style in [STYLE_SOCKET, STYLE_PSL]:
        if shape == SHAPE_STRAIGHT:
            invalid_arguments("This style only works with two pin rows")
        if row_distance != mil(100.):
            invalid_arguments(
                "This style does not work with a custom row distance")

    start(None, name, name, name, zero, zero,
          text_x, text_y, text_dir, text_scale, None)

    for i in xrange(0, eff_pin_count):
        y = i * mil(100.)
        if i == 0:
            if shape == SHAPE_BA:
                maybe_square = []
                other_maybe_square = ['square']
            else:
                maybe_square = ['square']
                other_maybe_square = []
        else:
            maybe_square = []
            other_maybe_square = []

        if shape == SHAPE_ZIGZAG:
            i0, i1 = i * 2 + 1, i * 2 + 2
        if shape == SHAPE_USHAPED:
            i0, i1 = i + 1, pin_count - i
        if shape == SHAPE_AB:
            i0, i1 = 'A%d' % (i + 1), 'B%d' % (i + 1)
        if shape == SHAPE_BA:
            i0, i1 = 'B%d' % (i + 1), 'A%d' % (i + 1)

        if shape == SHAPE_STRAIGHT:
            pin(zero, y, pin_thickness, pin_clearance, pin_mask, pin_drill,
                i + 1, flags = maybe_square)
            pad(-pad_length / 2, y, pad_length / 2, y,
                pad_thickness, pad_clearance, pad_mask,
                i + 1, flags = ['onsolder'] + maybe_square)
        elif row_distance < mil(100.) + pad_length:
            pin(zero, y,
                pin_thickness, pin_clearance, pin_mask, pin_drill,
                i0, flags = maybe_square)
            pin(width, y,
                pin_thickness, pin_clearance, pin_mask, pin_drill,
                i1, flags = other_maybe_square)
            pad(-pad_length, y, zero, y,
                pad_thickness, pad_clearance, pad_mask,
                i0, flags = ['onsolder'] + maybe_square)
            pad(width, y, width + pad_length, y,
                pad_thickness, pad_clearance, pad_mask,
                i1, flags = ['onsolder', 'edge2'] + other_maybe_square)
        else:
            pin(zero, y,
                pin_thickness, pin_clearance, pin_mask, pin_drill,
                i0, flags = maybe_square)
            pad(-pad_length / 2, y, pad_length / 2, y,
                pad_thickness, pad_clearance, pad_mask,
                i0, flags = ['onsolder'] + maybe_square)
            pin(width, y,
                pin_thickness, pin_clearance, pin_mask, pin_drill,
                i1, flags = other_maybe_square)
            pad(width - pad_length / 2, y, width + pad_length / 2, y,
                pad_thickness, pad_clearance, pad_mask,
                i1, flags = ['onsolder', 'edge2'] + other_maybe_square)

    # Paint outline

    if style == STYLE_THICKENED:
        # thick line
        line(x0, y0, x1, y0)
        line(x0, y0 + mil(5.), x1, y0 + mil(5.))
        line(x0, y0 + mil(10.), x1, y0 + mil(10.))
    elif style == STYLE_DENT:
        # dent
        line(x0, y0, width / 2 - mil(50.), y0)
        arc(width / 2, y0, mil(50.), mil(50.), 0, 90)
        arc(width / 2, y0, mil(50.), mil(50.), 90, 90)
        line(width / 2 + mil(50.), y0, x1, y0)
    elif style == STYLE_BOXED:
        # box around pin 1
        line(x0, y0, x1, y0)
        if shape == SHAPE_BA:
            line(mil(150.), mil(50.), mil(50.), mil(50.))
        else:
            line(mil(-50.), mil(50.), mil(50.), mil(50.))
        line(mil(50.), mil(-50.), mil(50.), mil(50.))
    elif style == STYLE_SOCKET:
        line(mil(-30.), mil(-50.), mil(130.), mil(-50.))
        for i in xrange(0, eff_pin_count):
            line(mil(-30.), i * mil(100.) - mil(50.),
                 mil(-50.), i * mil(100.) - mil(30.))
            line(mil(-50.), i * mil(100.) - mil(30.),
                 mil(-50.), i * mil(100.) + mil(30.))
            line(mil(-50.), i * mil(100.) + mil(30.),
                 mil(-30.), i * mil(100.) + mil(50.))

            line(mil(130.), i * mil(100.) - mil(50.),
                 mil(150.), i * mil(100.) - mil(30.))
            line(mil(150.), i * mil(100.) - mil(30.),
                 mil(150.), i * mil(100.) + mil(30.))
            line(mil(150.), i * mil(100.) + mil(30.),
                 mil(130.), i * mil(100.) + mil(50.))

        line(mil(-30.), eff_pin_count * mil(100.) - mil(50.),
             mil(130.), eff_pin_count * mil(100.) - mil(50.))
    elif style == STYLE_WSL_ARROW:
        # arrow
        line(x0, y0, x1, y0)
        line(mil(-125.), mil(50.), mil(-75.), mil(0.))
        line(mil(-75.), mil(0.), mil(-125.), mil(-50.))
    elif style == STYLE_WSL_DENT:
        # dent
        line(x0, y0, x1, y0)
        line(x0, height / 2 - mil(100.),
             x0 + mil(50.), height / 2 - mil(100.))
        line(x0 + mil(50.), height / 2 - mil(100.),
             x0 + mil(50.), height / 2 + mil(100.))
        line(x0 + mil(50.), height / 2 + mil(100.),
             x0, height / 2 + mil(100.))
    elif style == STYLE_PSL:
        # bottom part
        pin(mil(50.), height + mil(231.10),
            mil(147.80), mil(121.37), mil(151.74), mil(118.11), 0)
        line(mil(299.21), height + mil(427.75),
             mil(929.13), height + mil(683.66))
        line(mil(653.54), height + mil(408.07),
             mil(968.50), height + mil(604.92))
        line(mil(653.54), height + mil(152.16),
             mil(456.69), height + mil(152.16))
        line(mil(653.54), height + mil(408.07),
             mil(653.54), height + mil(152.16))
        line(mil(220.47), height + mil(427.76),
             mil(653.54), height + mil(408.07))
        line(mil(870.079), height + mil(486.80),
             mil(850.40), height + mil(526.17))
        line(mil(889.77), height + mil(427.75),
             mil(870.079), height + mil(486.80))
        line(mil(988.189), height + mil(506.49),
             mil(889.77), height + mil(427.75))
        line(mil(50.), height + mil(216.10),
             mil(50.), height + mil(246.10))
        line(mil(35.), height + mil(231.10),
             mil(65.), height + mil(231.10))
        line(mil(988.189), height + mil(624.60),
             mil(988.189), height + mil(506.49))
        line(mil(988.189), height + mil(624.60),
             mil(968.50), height + mil(604.92))
        arc(mil(50.), height + mil(231.10),
            mil(125.), mil(125.), 35, 290)
        arc(mil(929.13), height + mil(624.60),
            mil(59.06), mil(59.06), 90, 90)

        # top part
        pin(mil(50.), mil(-231.10),
            mil(147.80), mil(123.37), mil(151.74), mil(118.11), 0)
        line(mil(299.21), mil(-427.75), mil(929.13), mil(-683.66))
        line(mil(653.54), mil(-408.07), mil(968.50), mil(-604.92))
        line(mil(653.54), mil(-152.16), mil(456.69), mil(-152.16))
        line(mil(653.54), mil(-408.07), mil(653.54), mil(-152.16))
        line(mil(220.47), mil(-427.76), mil(653.54), mil(-408.07))
        line(mil(870.079), mil(-486.80), mil(850.40), mil(-526.17))
        line(mil(889.77), mil(-427.75), mil(870.079), mil(-486.80))
        line(mil(988.189), mil(-506.49), mil(889.77), mil(-427.75))
        line(mil(50.), mil(-216.10), mil(50.), mil(-246.10))
        line(mil(35.), mil(-231.10), mil(65.), mil(-231.10))
        line(mil(988.189), mil(-624.60), mil(988.189), mil(-506.49))
        line(mil(988.189), mil(-624.60), mil(968.50), mil(-604.92))
        arc(mil(50.), mil(-231.10), mil(125.), mil(125.), 35, 290)
        arc(mil(929.13), mil(-624.60), mil(59.06), mil(59.06), 180, 90)

        # box
        line(mil(-55.12), height + mil(428.15),
             mil(259.84), height + mil(428.15))
        line(mil(-55.12), mil(-427.76), mil(-55.12), height + mil(428.15))
        line(mil(456.69), height + mil(418.32), mil(456.69), mil(-417.91))
        line(mil(220.47), mil(-427.76), mil(-55.12), mil(-427.76))

        # mark on the left
        line(mil(-75.), mil(0.), mil(-125.), mil(-50.))
        line(mil(-125.), mil(50.), mil(-75.), mil(0.))

        # mark in the middle
        line(mil(50.), height / 2 - mil(50.), mil(50.), height / 2)
        line(mil(50.), height / 2, mil(100.), height / 2)
        line(mil(50.), height / 2 + mil(50.), mil(50.), height / 2)
        line(mil(50.), height / 2, mil(0.), height / 2)
    else:
        raise ValueError

    if style not in [STYLE_SOCKET, STYLE_PSL]:
        line(x1, y0, x1, y1)
        line(x1, y1, x0, y1)
        line(x0, y1, x0, y0)

    end()

if __name__ == '__main__':
    main()
